using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class Movement : MonoBehaviour
{
    // the speed value of which Wei walks. can be changed in the inspector at any time.
    public float speed = 0.5f;
    private Vector2 input;
    // the direction which the player last moved.
    private Vector2 lastMoveDirection;

    // a value determining how long you've been holding your breath for when hiding. Kicks you out when a certain
    // value is reached. Ensures that you never sit back and hide the whole round.
    public float holdBreathTime = 0f;

    // the rigidbody, animator and object of the player "Wei", which will be referred to in order to animate him and
    // collide with other objects such as enemy trigger boxes.
    public Rigidbody2D rb;    
    Animator myAnim;
    public GameObject player;
    
    // The image of the "Filler" inside the noise bar, but not the BG, as the background will never need to be changed.
    public Image NoiseBar;
    // a float of the current noise being generated by steps, and the maximum volume before getting caught.
    public float Noise, MaxNoise;

    // if hiding is a possibility; only activates near hiding spots (red)
    public bool canHide;
    // if Wei is currently hiding or not.
    public bool isHiding;
    // if Wei can move or not.
    public bool canMove;
    // if Wei is currently moving or not.
    public bool ismoving;

    // if Wei is walking slow. I typed it in as 'crouched' because I previously had the idea for a seperate crouching
    // animation, but decided against it. No one crawls around the floor when they're trying to sneak around.
    public bool crouched;

    // The game starts, and Wei can automatically move, and is not crouched. The animator is also immediately fetched
    // So that he can be animated instantly.
    void Start()
    {
        canMove = true;
        myAnim = GetComponent<Animator>();
    }

    // Update is called once per frame
    private void Update()
    {
        ProcessInputs();
        Animate();

        // If you're not crouching and you hold Left Shift, crouched becomes true, and your speed slows significantly.
        if (crouched == false && Input.GetKeyDown(KeyCode.LeftShift))
        {
            crouched = true;
            speed = 1f;
        }

        // If you're currently crouched and you let go of Left Shift, your speed returns to normal.
        if (crouched = true & Input.GetKeyUp(KeyCode.LeftShift))
        {
            //crouched = false;
            speed = 3f;
        }

        // If it's possible to hide and you press down "F" while not currently hiding, you will disappear into a box,
        // and lose the ability to move. 
        if (canHide == true & Input.GetKeyDown(KeyCode.F))
        {
            if (isHiding == false)
            {
                isHiding = true;
                canMove = false;

                // Also, your Gameobject will no longer be enabled. This is simply because I have no hiding animation.
                player.GetComponent<Renderer>().enabled = false;
            }
        }

        if (isHiding = true & Input.GetKeyUp(KeyCode.F))
        {
            if (isHiding == true)
            {
                isHiding = false;
                canMove = true;
                player.GetComponent<Renderer>().enabled = true;
            }
        }
    }

    private void FixedUpdate()
    {
        // If moving is possible, velocity should be equal to the input value and the current speed value.
        if (canMove)
        {
            rb.velocity = input * speed;
        }
        else // alternatively, your velocity will drop to zero and be motionless.
        {
            rb.velocity = Vector2.zero;
        }
    }

    void ProcessInputs()
    {
        // assigning the word "moveX" and "moveY" to the axis of horizontal (X) and vertical (Y), which is already
        // defined by unity in a pre-existing library.
        float moveX = Input.GetAxisRaw("Horizontal");
        float moveY = Input.GetAxisRaw("Vertical");

        // if the player is not moving in the x OR y axis, and (for example) the input of X is also zero, then the
        // direction of the player will face the direction assigned to the Y input (or vice versa).
        if ((moveX == 0 && moveY == 0 ) && (input.x != 0 || input.y != 0))
        {
            lastMoveDirection = input;
        }

        // Ensures movement on X axis is aligned with the X axis buttons (A, D)
        // same for the Y axis (W, S)
        input.x = Input.GetAxisRaw("Horizontal");
        input.y = Input.GetAxisRaw("Vertical");
        
        if ((input.x != 0 || input.y != 0) && !crouched)
        {
            ismoving = true;
        }
        else
        {
            ismoving = false;
        }

        // if the player iz not at velocity zero but also not crouched, (aka, walking freely)
        // noise will increase in proportion to speed. necessary for determining how much noise you're generating.
        // Noise will never exceed more than its maximum.
        if (ismoving && !crouched)
        {
            Noise += 0.01f;
            NoiseBar.fillAmount = Noise / MaxNoise;
            if (Noise > 100)
            {
                Noise = 100;
            } 
        }

        // Ensures that the diagonal movements are not twice as fast as the linear movements.
        input.Normalize();
    }    

    void Animate()
    {
        // Aligns float values of "input.x" to the MoveX value in the animator. Move X will be true for all animated
        // movements on the X axis, and diagonal ones(both X and Y).
        myAnim.SetFloat("MoveX", input.x);
        // same goes for Y
        myAnim.SetFloat("MoveY", input.y);

        // The magnitude of which the player is animates/moves
        myAnim.SetFloat("MoveMagnitude", input.magnitude);
        // The last movement being X, and being Y.
        myAnim.SetFloat("LastMoveX", lastMoveDirection.x);
        myAnim.SetFloat("LastMoveY", lastMoveDirection.y);
    }

    private void OnTriggerEnter2D(Collider2D coll)
    {
        if (coll.gameObject.tag == "Hiding Spot")
        {
            canHide = true;
        }

        if ((coll.gameObject.tag == "Enemy") && !isHiding)
        {
            canMove = false;
            Debug.Log("HEY!!!!!");
            //and then you lose
        }
           
    }

    private void OnTriggerExit2D(Collider2D collex)
    {
        canHide = false;
    }
}